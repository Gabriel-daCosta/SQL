--Localiza nas tabelas dos banco de dados, as colunas que possuem o texto procurado

-- Substitua 'ProcuraColuna' pelo texto que voc√™ quer encontrar nos nomes das colunas
DECLARE @ProcuraColuna NVARCHAR(128) = 'UNIDADE';

-- Constr√≥i o SQL dinamicamente para cada banco com permiss√£o
DECLARE @SQL NVARCHAR(MAX) = '';

SELECT @SQL = @SQL + 
    CASE 
        WHEN @SQL = '' THEN '' 
        ELSE ' UNION ALL ' 
    END +
    'SELECT ' +
        '''' + name + ''' AS DATABASE_NAME, ' +
        'TABLE_NAME, ' +
        'COLUMN_NAME, ' +
        'DATA_TYPE, ' +
        'CHARACTER_MAXIMUM_LENGTH, ' +
        'NUMERIC_PRECISION, ' +
        'NUMERIC_SCALE, ' +
        'IS_NULLABLE, ' +
        'COLUMN_DEFAULT, ' +
        'ORDINAL_POSITION ' +
    'FROM [' + name + '].INFORMATION_SCHEMA.COLUMNS ' +
    'WHERE UPPER(COLUMN_NAME) LIKE UPPER(''%' + @ProcuraColuna + '%'')'
FROM sys.databases 
WHERE state = 0 
  AND database_id > 4 
  AND HAS_DBACCESS(name) = 1;

-- Adiciona ordena√ß√£o final
IF @SQL <> ''
    SET @SQL = @SQL + ' ORDER BY DATABASE_NAME, TABLE_NAME, ORDINAL_POSITION;';

-- Executa apenas se houver bancos para consultar
IF @SQL <> ''
    EXEC sp_executesql @SQL
ELSE
    PRINT 'Nenhum banco acess√≠vel encontrado.';



/*

üéØ Vis√£o Geral e Explica√ß√£o do C√≥digo:

Este c√≥digo busca colunas por nome em todos os bancos de dados e retorna um resultado unificado sem precisar de permiss√µes de escrita.
üìù Explica√ß√£o Passo a Passo:

1. Declara√ß√£o das Vari√°veis
DECLARE @ProcuraColuna NVARCHAR(128) = '*TextoProcurado*';
DECLARE @SQL NVARCHAR(MAX) = '';
O que faz:

@ProcuraColuna: Armazena o texto que voc√™ quer encontrar nos nomes das colunas
@SQL: Vai acumular todo o comando SQL que ser√° constru√≠do dinamicamente
Observa√ß√£o: Voc√™ mudou o nome da vari√°vel para @ProcuraColuna (mais intuitivo que @SearchText4)

2. Constru√ß√£o do SQL Din√¢mico com UNION ALL
SELECT @SQL = @SQL + 
    CASE 
        WHEN @SQL = '' THEN '' 
        ELSE ' UNION ALL ' 
    END +
O que acontece:

SELECT @SQL = @SQL +: Para cada banco encontrado, concatena mais SQL √† vari√°vel
CASE WHEN @SQL = '': Se for o primeiro banco, n√£o adiciona "UNION ALL"
ELSE ' UNION ALL ': Para os demais bancos, adiciona "UNION ALL" antes do SELECT

Resultado pr√°tico:
-- Primeiro banco: apenas "SELECT..."
-- Segundo banco: "UNION ALL SELECT..."  
-- Terceiro banco: "UNION ALL SELECT..."

3. Constru√ß√£o do SELECT para Cada Banco
'SELECT ' +
    '''' + name + ''' AS DATABASE_NAME, ' +
    'TABLE_NAME, ' +
    'COLUMN_NAME, ' +
    'DATA_TYPE, ' +
    'CHARACTER_MAXIMUM_LENGTH, ' +
    'NUMERIC_PRECISION, ' +
    'NUMERIC_SCALE, ' +
    'IS_NULLABLE, ' +
    'COLUMN_DEFAULT, ' +
    'ORDINAL_POSITION ' +
'FROM [' + name + '].INFORMATION_SCHEMA.COLUMNS ' +
'WHERE UPPER(COLUMN_NAME) LIKE UPPER(''%' + @ProcuraColuna + '%'')'
Traduzindo cada parte:

'''' + name + ''' AS DATABASE_NAME:

Pega o nome do banco da vari√°vel name
Transforma em string literal: 'DMD47' AS DATABASE_NAME

FROM [' + name + '].INFORMATION_SCHEMA.COLUMNS:

Refer√™ncia direta: FROM [DMD47].INFORMATION_SCHEMA.COLUMNS
N√£o usa USE - acessa o banco diretamente


WHERE UPPER(COLUMN_NAME) LIKE UPPER(...):

Case-insensitive: ignora mai√∫sculas/min√∫sculas
%TextoProcurado%: busca o texto em qualquer parte do nome da coluna

4. Filtro de Bancos
FROM sys.databases 
WHERE state = 0 
  AND database_id > 4 
  AND HAS_DBACCESS(name) = 1;
Cada condi√ß√£o:

state = 0: Apenas bancos online (n√£o em restore, offline, etc.)
database_id > 4: Exclui bancos de sistema (master=1, model=3, msdb=4, tempdb=2)
HAS_DBACCESS(name) = 1: Apenas bancos que voc√™ tem permiss√£o de acessar

5. Adi√ß√£o da Ordena√ß√£o
IF @SQL <> ''
    SET @SQL = @SQL + ' ORDER BY DATABASE_NAME, TABLE_NAME, ORDINAL_POSITION;';
O que faz:

Verifica se h√° algum SQL constru√≠do (@SQL <> '')
Adiciona ordena√ß√£o ao final de toda a consulta unificada
Ordena por: Banco ‚Üí Tabela ‚Üí Posi√ß√£o da Coluna

6. Execu√ß√£o Condicional
IF @SQL <> ''
    EXEC sp_executesql @SQL
ELSE
    PRINT 'Nenhum banco acess√≠vel encontrado.';
L√≥gica:

Se construiu algum SQL: Executa a consulta
Se n√£o encontrou bancos: Mostra mensagem informativa
sp_executesql: Mais seguro que EXEC simples para SQL din√¢mico

üéØ Exemplo do SQL Final Gerado:
Se voc√™ tivesse bancos "DMD47" e "WORK_GEPLAC", o @SQL final seria:
SELECT 'DMD47' AS DATABASE_NAME, TABLE_NAME, COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, IS_NULLABLE, COLUMN_DEFAULT, ORDINAL_POSITION FROM [DMD47].INFORMATION_SCHEMA.COLUMNS WHERE UPPER(COLUMN_NAME) LIKE UPPER('%UNIDADE%') 
UNION ALL 
SELECT 'WORK_GEPLAC' AS DATABASE_NAME, TABLE_NAME, COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, IS_NULLABLE, COLUMN_DEFAULT, ORDINAL_POSITION FROM [WORK_GEPLAC].INFORMATION_SCHEMA.COLUMNS WHERE UPPER(COLUMN_NAME) LIKE UPPER('%UNIDADE%') 
ORDER BY DATABASE_NAME, TABLE_NAME, ORDINAL_POSITION;

‚ú® Por que Este C√≥digo √© Excelente:

‚úÖ Uma √∫nica tabela de resultado (UNION ALL unifica tudo)
‚úÖ Sem permiss√µes de escrita (s√≥ SELECT)
‚úÖ Tratamento de casos especiais (se n√£o encontrar bancos)
‚úÖ Busca case-insensitive (UPPER em ambos os lados)
‚úÖ Filtros inteligentes de seguran√ßa e permiss√£o
‚úÖ Resultado bem organizado (ordenado logicamente)

üîç Fluxo de Execu√ß√£o Resumido:

Define o texto a procurar
Lista todos os bancos acess√≠veis
Para cada banco: Constr√≥i um SELECT que busca colunas com o texto
Une tudo com UNION ALL
Adiciona ordena√ß√£o ao final
Executa a consulta unificada
Retorna uma tabela √∫nica com todos os resultados

*/
